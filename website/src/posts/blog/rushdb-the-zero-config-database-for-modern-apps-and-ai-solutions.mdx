---
title: "RushDB: Zero-Config Instant Database for Modern Apps & AI Era"
description: "RushDB is a zero-config, graph-powered instant database with bulk semi-structured data ingestion, automatic normalization, and powerful querying."
image: "/images/blog/default.png"
tags: ["database", "graph database", "NoSQL", "developer tools", "data normalization", "instant database"]
date: "02/06/2025"
---

# Introducing RushDB: Zero-Config Instant Database for Modern Apps & the AI Era

RushDB is an instant database for modern apps and DS/ML ops built on top of Neo4j.

In a world where developers demand speed, simplicity, and efficiency, **RushDB** emerges as a **zero-config, instant database** built for modern applications and the AI-driven era. With **automatic data normalization, ACID compliance, and native graph capabilities**, RushDB offers a powerful, developer-friendly solution for handling structured and semi-structured data effortlessly.

## Why RushDB?
Traditional databases require extensive setup, schema definitions, and manual optimization. RushDB eliminates these barriers with:

- **Zero Configuration** – Just push any JSON or CSV; RushDB takes care of the rest.
- **Graph-Powered Storage** – Automatically structures relationships between data.
- **ACID Transactions** – Ensures consistency and reliability.
- **Powerful Queries with Simple SDKs** – NoSQL flexibility with SQL-like expressiveness.
- **Self-Hosted or Cloud** – Deploy anywhere with ease.

## Key Features
### 1. Accepts Any JSON, JSONB, and CSV Data
RushDB allows developers to push raw JSON or CSV data without worrying about schema definitions. RushDB **automatically normalizes data** and structures it as a graph, making queries fast and intuitive.

#### Create Record

```sdk
from rushdb import RushDB

db = RushDB("API_TOKEN")

data = {
    "name": "Google LLC",
    "address": "1600 Amphitheatre Parkway, Mountain View, CA 94043, USA",
    "foundedAt": "1998-09-04T00:00:00.000Z",
    "rating": 4.9
}

record = db.records.create("COMPANY", data)
___SPLIT___
const db = new RushDB('API_TOKEN');

const data = {
    name: 'Google LLC',
    address: '1600 Amphitheatre Parkway, Mountain View, CA 94043, USA',
    foundedAt: '1998-09-04T00:00:00.000Z',
    rating: 4.9
}

const record = await db.records.create("COMPANY", data)
```

#### Query Records

```sdk
query = {
    "labels": ["COMPANY"],
    "where": {
        "name": {"$contains": "Goog"},
        "rating": {"$gte": 4}
    }
}

records = db.records.find(query)
___SPLIT___
const records = await db.records.find({
    labels: ['COMPANY'],
    where: {
        name: { $contains: 'Goog' },
        rating: { $gte : 4 }
    }
})
```

### 2. Automatic Data Normalization and Type Inference
RushDB takes raw input data and **automatically structures it** into a connected graph, allowing for seamless navigation across relationships.

#### Example JSON data

```json
/* ORDER */
{
  "total": 109.98,                           <-- PROPERTY total:`number`
  "status": "processing",                    <-- PROPERTY status:`string`
  "placedAt": "2025-02-15T09:35:26+00:00",   <-- PROPERTY placedAt:`datatime`
  "SHIPPING": {                              <-- RECORD :SHIPPING
    "address": "123 Main St, City, Country", <-- PROPERTY address:`string`
    "method": "express",                     <-- PROPERTY method:`string`
    "cost": 9.99                             <-- PROPERTY cost:`number`
  }
}
```

Above payload will be automatically normalized into separate **flat** Records. And relationship between ORDER and SHIPPING will be created automatically.


### 3. Relationships
RushDB automatically creates relationships between records based on JSON input, which is normalized into separate flat records.

However, relationship creation isn't limited to data loading. You can also establish relationships between existing records, providing a powerful tool to add more meaning to your data.

Managing Relationships:

```sdk
project = db.records.create(
    "PROJECT", {"name": "Secret Project", "budget": 1000000}
)

employee = db.records.create(
    "EMPLOYEE", {"name": "Nikola Tesla"}
)

options = RelationshipOptions(type="HAS_EMPLOYEE")

# create Relationship
project.attach(employee, options)

# delete Relationship
project.detach(employee)
___SPLIT___
const project = await db.records.create('PROJECT', {
    name: 'Secret Project',
    budget: 1000000
})

const employee = await db.records.create('EMPLOYEE', {
    name: 'Nikola Tesla'
})

// create Relationship
await project.attach(employee, { type: 'HAS_EMPLOYEE' })

// delete Relationship
await project.detach(employee)
```

### 4. Query Smarter, Not Harder
Effortlessly find exactly what you need. With automated, on-the-fly data normalization, you can query complex, deeply interconnected data without workarounds or unnecessary overhead - just clear, intuitive access to your data.
#### Examples

```sdk
db.records.find(
    {
        "labels": ["COMPANY"],
        "where": {
            "stage": "seed",
            "address": {"$contains": "USA"},
            "foundedAt": {"$lte": {"$year": 2000}},
            "rating": {
                "$or": [{"$lt": 2.5}, {"$gte": 4.5}]
            },
            "EMPLOYEE": {
                "$relation": {"type": "HIRED", "direction": "out"},
                "$alias": "$employee",
                "salary": {
                    "$gte": 500_000
                }
            },
        },
        "aggregate": {
            "employees": {
                "fn": "collect",
                "alias": "$employee",
                "limit": 10
            }
        },
        "skip": 0,
        "limit": 100
    }
)
___SPLIT___
await db.records.find({
  labels: ['COMPANY'],
  where: {
    stage: 'seed',
    address: { $contains: 'USA' },
    foundedAt: {
      $lte: { $year: 2000 }
    },
    rating: {
      $or: [{ $lt: 2.5 }, { $gte: 4.5 }]
    },
    EMPLOYEE: {
      $relation: { type: 'HIRED', direction: 'out' },
      $alias: '$employee',
      salary: {
        $gte: 500_000
      }
    }
  },
  aggregate: {
    employees: {
      fn: 'collect',
      alias: '$employee',
      limit: 10
    }
  },
  skip: 0,
  limit: 100
})
```

Under the hood, RushDB transforms this into an optimized and powerful Cypher query. The query engine allows developers to think about data naturally, the way we intuitively use and perceive it, while RushDB handles the complexity behind the scenes:

```cypher
MATCH (record:__RUSHDB__LABEL__RECORD__:COMPANY { __RUSHDB__KEY__PROJECT__ID__: $projectId })

WHERE (any(value IN record.stage WHERE value = "seed"))
AND (any(value IN record.address WHERE value =~ "(?i).*USA.*"))
AND (any(value IN record.foundedAt WHERE apoc.convert.fromJsonMap(`record`.`__RUSHDB__KEY__PROPERTIES__META__`).`foundedAt` = "datetime" AND datetime(value) <= datetime({year: 2000})))
AND ((any(value IN record.rating WHERE value < 2.5) OR any(value IN record.rating WHERE value >= 4.5)))

ORDER BY record.`__RUSHDB__KEY__ID__`
DESC SKIP 0 LIMIT 100

OPTIONAL MATCH (record)-[:HIRED]->(record1:EMPLOYEE) WHERE (any(value IN record1.salary WHERE value >= 500000))
WITH record, record1
WHERE record IS NOT NULL AND record1 IS NOT NULL

WITH record,
apoc.coll.sortMaps(collect(DISTINCT record1 {
    .*, __RUSHDB__KEY__LABEL__: [label IN labels(record1) WHERE label <> "__RUSHDB__LABEL__RECORD__"][0]
}), "__RUSHDB__KEY__ID__")[0..10] AS `employees`

RETURN collect(DISTINCT record {
    __RUSHDB__KEY__ID__: record.__RUSHDB__KEY__ID__,
    __RUSHDB__KEY__PROPERTIES__META__: record.__RUSHDB__KEY__PROPERTIES__META__,
    __RUSHDB__KEY__LABEL__: [label IN labels(record) WHERE label <> "__RUSHDB__LABEL__RECORD__"][0],
    `employees`
}) AS records
```

### 5. Transactions
RushDB is fully ACID-compliant, providing robust tools to ensure data consistency and reliability. With the Transactions API, you can execute multiple operations confidently - either every request completes successfully, or all changes are rolled back, maintaining data integrity.

Working with transactions in RushDB is seamless:

```sdk
tx = db.transactions.begin()

try:
    # Create some Records
    item = db.records.create(
        "ITEM",
        {"title": "Nike Air Max 270", "price": 150},
        transaction=tx,
    )

    owner = db.records.create(
        "OWNER",
        {"name": "Jane Smith", "email": "janesmith@example.com"},
        transaction=tx
    )

    options = RelationshipOptions(type="OWN", direction="out")

    # create Relationship
    owner.attach(item, options, transaction=tx)

    # Simulate an error
    raise ValueError("Simulated error")

    # Commit the Transaction if all operations succeed
    tx.commit();

except ValueError:
    #  If any records or relationships creation failed, roll back the entire operation
    transaction.rollback()
___SPLIT___
const tx = await db.tx.begin();

try {
  // Create some Records
  const item = await db.records.create('ITEM', {
    title: 'Nike Air Max 270',
    price: 150
  }, tx);

  const owner = await db.records.create('OWNER', {
    name: 'Jane Smith',
    email: 'janesmith@example.com',
  }, tx);

  // create Relationship
  await owner.attach(item, {
    type: 'OWN',
    direction: 'out',
  }, tx);

  // Simulate an error
  throw new Error('Simulated error')

  // Commit the Transaction if all operations succeed
  await tx.commit();
} catch (e) {
  // If any Records or Relationships creation failed, roll back the entire operation
  await tx.rollback();
}
```

### 6. Powerful Dashboard
RushDB natively supports **text-based search queries**, eliminating the need for external indexing services.

///

## Use Cases
### SaaS & Apps
RushDB is perfect for modern SaaS applications requiring **fast, schema-less data ingestion and querying**.

### AI & ML Research
With its **graph-powered** structure, RushDB simplifies working with interconnected datasets, making it ideal for **AI-driven applications**.

### IoT & Search Engines
RushDB efficiently stores and retrieves **large-scale IoT data** and **searchable content** with built-in indexing.

## Get Started
You can **self-host** RushDB or opt for **RushDB Cloud** for a fully managed experience.

Try it today and **supercharge your data workflows with RushDB**!
